import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    // Indices of user inputs in user input array
    private static int N_INDEX = 0;
    private static int S_INDEX = 1;
    private static int E_INDEX = 2;

    public static void main(String[] args) {
        try {
            // Get input from user for number of intervals, and range of times
            int[] userInputs = getInputs();

            // Create random intervals within the defined time range
            ArrayList<Interval> intervalList = createIntervalList(userInputs[N_INDEX], userInputs[S_INDEX],
                    userInputs[E_INDEX]);

            // Apply greedy scheduling algorithm
            ArrayList<Interval> schedule = intervalScheduler(intervalList);

            // Apply greedy partition algorithm
            HashMap<Integer, ArrayList<Interval>> partition = intervalPartitioner(intervalList);

            // Print results
            printScheduleResults(schedule);
            printPartitionResults(partition);

        }catch (IOException e){
            System.out.println("ERROR - UNABLE TO RETRIEVE USER INPUT, PLEASE TRY AGAIN");
        }
    }

    /**
     * Applies Scheduling algorithm defined on page 118 of Algorithm Design (Kleinberg, Tardos)
     * @param intervalList      list of randomly generated Interval objects
     * @return                  list that is a subset of the input list under the condition that no two Interval
     *                          objects overlap and that the length of the list is maximized
     */
    private static ArrayList<Interval> intervalScheduler(ArrayList<Interval> intervalList){
        ArrayList<Interval> results = new ArrayList<>();
        ArrayList<Interval> intervalCopy = makeCopy(intervalList, true);

        while(intervalCopy.size() > 0){
            Interval currentInterval = intervalCopy.get(0);
            intervalCopy.remove(0);

            ArrayList<Interval> toRemove = new ArrayList<>();
            for (Interval v: intervalCopy)
                if (v.conflictsWith(currentInterval))
                    toRemove.add(v);
            intervalCopy.removeAll(toRemove);

            results.add(currentInterval);
        }

        return results;
    }

    /**
     * Applies Partitioning algorithm defined on page 124 of Algorithm Design (Kleinberg, Tardos)
     * @param intervalList      list of randomly generated Interval objects
     * @return                  a HashMap where the key is the partition label and the value is an array list of
     *                          Interval objects. Each key's list contains no Interval objects that conflict.
     */
    private static HashMap<Integer, ArrayList<Interval>> intervalPartitioner(ArrayList<Interval> intervalList){
        HashMap<Integer, ArrayList<Interval>> results = new HashMap<>();
        ArrayList<Interval> intervalCopy = makeCopy(intervalList, false);

        int numberOfLabels = 1;
        for(int j = 0; j < intervalCopy.size(); j++){
            Interval intervalJ = intervalCopy.get(j);
            ArrayList<Integer> possibleLabels = genLabelList(numberOfLabels);

            for(int i = 0; i < j; i ++){
                if (possibleLabels.size() == 0)
                    break;

                Interval intervalI = intervalCopy.get(i);
                if(intervalI.conflictsWith(intervalJ)){
                    int iLabel = intervalI.getPartitionLabel();
                    possibleLabels.remove(new Integer(iLabel));
                }
            }

            if(possibleLabels.size() > 0){
                intervalJ.setPartitionLabel(possibleLabels.get(0));
            }else{
                intervalJ.setPartitionLabel(numberOfLabels + 1);
                numberOfLabels += 1;
            }

            int key = intervalJ.getPartitionLabel();
            results.computeIfAbsent(key, k -> new ArrayList<>());
            results.get(key).add(intervalJ);
        }
        return results;
    }

    /**
     * Creates a list of randomly generated Interval objects. Start time is generated by adding the user defined minimum
     * start time and a randomly generated integer between 0 and the width of the time interval specified by the minimum
     * and maximum time defined by the user. End time is the sum of the randomly generated start time and the an integer
     * that fits in the left over width of the time interval. This is done so that each randomly generated Interval
     * object defines a valid interval where the start time is less than the end time.
     * @param length        the number of Interval objects to create
     * @param minStart      the minimum start time defined by the user
     * @param maxEnd        the maximum start time defined by the user
     * @return              a list of randomly generated Interval objects
     */
    private static ArrayList<Interval> createIntervalList(int length, int minStart, int maxEnd){
        ArrayList<Interval> intervalList = new ArrayList<>(length);

        Random generator = new Random(System.currentTimeMillis());
        for (int i = 0; i < length; i ++){
            int startTime = minStart + generator.nextInt(maxEnd - minStart);
            int endTime = startTime + generator.nextInt(maxEnd - startTime) + 1;

            intervalList.add(new Interval(i+1, startTime, endTime));
        }

        return intervalList;
    }

    /**
     * Asks the user for the number of intervals to create, the minimum start time, and the maximum end time. Verifies
     * the time interval specified by the user is valid.
     * @return                  an array [number of intervals, min. start time, max end time]
     * @throws IOException      thrown when program cannot retrieve user input
     */
    private static int[] getInputs() throws IOException {
        BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in));

        String intervalMessage = "Please enter the amount of intervals you want to create: ";
        int nIntervals = getInput(userInput, intervalMessage);

        boolean validInterval = false;
        int tStart = -1;
        int tEnd = -1;
        while (!validInterval) {
            String startTimeMessage = "Please enter the minimum start time: ";
            tStart = getInput(userInput, startTimeMessage);

            String endTimeMessage = "Please enter the maximum end time: ";
            tEnd = getInput(userInput, endTimeMessage);

            if(tStart < tEnd)
                validInterval = true;
            else
                System.out.println("\nError - the minimum start time must be greater than the maximum end time!\n");
        }

        return new int[]{nIntervals, tStart, tEnd};
    }

    /**
     * Displays a message to the user and retrieves their input if it is an integer and greater than zero.
     * @param reader            the BufferedReader to read user input
     * @param userMessage       the message/prompt to display to the user
     * @return                  the integer value entered by the user
     * @throws IOException      thrown when program cannot retrieve user input
     */
    private static int getInput(BufferedReader reader, String userMessage) throws IOException {
        while(true) {
            System.out.print(userMessage);
            String userInput = reader.readLine();
            try{
                int value = Integer.parseInt(userInput);
                if(value < 0)
                    throw new NumberFormatException(null);
                return value;
            }catch (NumberFormatException e){
                System.out.println("Input Error - Please enter a positive integer.");
            }
        }
    }

    /**
     * Creates a copy of the randomly generated interval list and ensures the list can be sorted according to the
     * algorithm's needs.
     * @param list          the Interval list to copy
     * @param sortByEnd     if true the Intervals will be sorted by their end times, otherwise will be sorted by start
     *                      times
     * @return              an array list of copied Interval objects sorted in the appropriate order
     */
    private static ArrayList<Main.Interval> makeCopy(ArrayList<Interval> list, boolean sortByEnd){
        ArrayList<Interval> intervalCopy = new ArrayList<>(list.size());
        for (Interval i: list)
            intervalCopy.add(i.cloneInterval(sortByEnd));
        Collections.sort(intervalCopy);

        return intervalCopy;
    }

    /**
     * Creates an array list of sequential integers from 1 to the input.
     * @param nLabels   the maximum sequential integer
     * @return          an array list containing all integers from 1 to input
     */
    private static ArrayList<Integer> genLabelList(int nLabels){
        ArrayList<Integer> labelList = new ArrayList<>(nLabels);
        for (int i = 1; i <= nLabels; i++){
            labelList.add(i);
        }
        return labelList;
    }

    /**
     * Prints out the results of the scheduling algorithm
     * @param schedule      result of scheduling algorithm
     */
    private static void printScheduleResults(ArrayList<Interval> schedule){
        System.out.println("Schedule Generated: ");
        for (int i = 0; i < schedule.size(); i ++){
            if(i != schedule.size() - 1)
                System.out.print(schedule.get(i) + ",  ");
            else
                System.out.println(schedule.get(i) + "\n");

        }
    }

    /**
     * Prints out the results of the partition algorithm
     * @param partition      result of partitioning algorithm
     */
    private static void printPartitionResults(HashMap<Integer, ArrayList<Interval>> partition){
        Set keys = partition.keySet();

        System.out.println("Partition Results: ");
        for(Object key: keys){
            ArrayList<Interval> results = partition.get(key);
            System.out.print("Label " + key + ": ");
            for (Interval i: results)
                System.out.print(i + "  ");
            System.out.println("");
        }
    }

    /**
     * Abstraction of each randomly generated interval
     */
    static class Interval implements Comparable{

        private int intervalLabel;
        private int startTime;
        private int endTime;

        private boolean sortByEndTime = true;
        private int partitionLabel;

        Interval(int index, int start, int end){
            this.intervalLabel = index;
            this.startTime = start;
            this.endTime = end;
        }

        boolean conflictsWith(Interval i) {
            if (this.startTime == i.getStartTime() || this.endTime == i.getEndTime())
                return true;
            else if (this.startTime <= i.getStartTime())
                return this.endTime >= i.getStartTime();
            else
                return i.getEndTime() >= this.startTime;
        }

        Interval cloneInterval(boolean sortByEndTime){
            Interval newInterval = new Interval(this.getIntervalLabel(), this.getStartTime(), this.getEndTime());
            newInterval.setSortByEndTime(sortByEndTime);

            return newInterval;
        }

        int getStartTime() {
            return startTime;
        }

        int getEndTime() {
            return endTime;
        }

        int getIntervalLabel(){
             return intervalLabel;
        }

        int getPartitionLabel(){ return partitionLabel; }

        void setPartitionLabel(int label){
            this.partitionLabel = label;
        }

        void setSortByEndTime(boolean sortByEndTime){
            this.sortByEndTime = sortByEndTime;
        }

        @Override
        public String toString() {
            return String.format("<%03d>: %05d -> %05d", intervalLabel, startTime, endTime);
        }

        @Override
        public int compareTo(Object o) {
            if (!(o instanceof Interval))
                throw new ClassCastException("This object is not an Interval!");
            else{
                Interval obj = (Interval) o;
                if(this.sortByEndTime)
                    return Integer.compare(this.endTime, obj.getEndTime());
                else
                    return Integer.compare(this.startTime, obj.getStartTime());
            }
        }
    }
}
